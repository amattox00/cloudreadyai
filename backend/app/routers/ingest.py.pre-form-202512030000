from typing import Optional, Dict, Any

from fastapi import APIRouter, Depends, File, UploadFile, HTTPException, Form
from sqlalchemy.orm import Session

from app.db import get_db
from app.modules.ingest.servers import ingest_servers_csv
from app.modules.ingest.storage import ingest_storage_csv
from app.modules.ingest.network import ingest_network_csv
from app.modules.ingest.databases import ingest_databases_csv
from app.modules.ingest.applications import ingest_applications_csv
from app.modules.ingest.business import ingest_business_csv
from app.modules.ingest.dependencies import ingest_dependencies_csv
from app.modules.ingest.os_software import ingest_os_csv
from app.modules.ingest.licensing import ingest_licensing_csv
from app.modules.ingest.utilization import ingest_utilization_csv
from app.routers.runs import increment_ingest_counts


router = APIRouter(
    prefix="/v1/ingest",
    tags=["ingest"],
)


def _extract_rows(result: Optional[Dict[str, Any]]) -> int:
    """
    Normalize row count from different ingest modules.

    Supports:
      - rows_ingested
      - rows_created
      - rows_read

    Falls back to 0 if nothing is present.
    """
    if not result:
        return 0

    return (
        result.get("rows_ingested")
        or result.get("rows_created")
        or result.get("rows_read")
        or 0
    )


async def _save_temp_file(upload: UploadFile, tmp_path: str, label: str) -> None:
    """
    Read the uploaded file contents and save to a temporary path.
    """
    contents = await upload.read()
    if not contents:
        raise HTTPException(
            status_code=400,
            detail=f"Uploaded {label} CSV is empty.",
        )

    try:
        with open(tmp_path, "wb") as f:
            f.write(contents)
    except Exception as e:  # noqa: BLE001
        raise HTTPException(
            status_code=500,
            detail=f"Failed to write temp {label} CSV: {e}",
        )


@router.post("/servers")
async def ingest_servers(
    file: UploadFile = File(..., description="Servers CSV"),
    run_id: Optional[str] = Form(None),
    db: Session = Depends(get_db),
):
    """
    Ingest a servers CSV and (optionally) attach the row count to a run.
    """
    tmp_path = "/tmp/ingest_servers.csv"
    await _save_temp_file(file, tmp_path, "servers")

    try:
        result = ingest_servers_csv(db=db, run_id=run_id or "", csv_path=tmp_path)
        rows = _extract_rows(result)
    except Exception as e:  # noqa: BLE001
        raise HTTPException(status_code=500, detail=f"Failed to ingest servers CSV: {e}")

    if run_id:
        try:
            increment_ingest_counts(run_id, servers=rows)
        except Exception:
            # Don't fail the request if stats update fails
            pass

    return {
        "kind": "servers",
        "rows_ingested": rows,
        "run_id": run_id,
        "message": f"Ingested {rows} server rows.",
    }


@router.post("/storage")
async def ingest_storage(
    file: UploadFile = File(..., description="Storage CSV"),
    run_id: Optional[str] = Form(None),
    db: Session = Depends(get_db),
):
    """
    Ingest a storage CSV and bump storage_ingested on the associated run.
    """
    tmp_path = "/tmp/ingest_storage.csv"
    await _save_temp_file(file, tmp_path, "storage")

    try:
        result = ingest_storage_csv(db=db, run_id=run_id or "", csv_path=tmp_path)
        rows = _extract_rows(result)
    except Exception as e:  # noqa: BLE001
        raise HTTPException(status_code=500, detail=f"Failed to ingest storage CSV: {e}")

    if run_id:
        try:
            increment_ingest_counts(run_id, storage=rows)
        except Exception:
            pass

    return {
        "kind": "storage",
        "rows_ingested": rows,
        "run_id": run_id,
        "message": f"Ingested {rows} storage rows.",
    }


@router.post("/network")
async def ingest_network(
    file: UploadFile = File(..., description="Network CSV"),
    run_id: Optional[str] = Form(None),
    db: Session = Depends(get_db),
):
    """
    Ingest a network CSV and bump network_ingested on the associated run.
    """
    tmp_path = "/tmp/ingest_network.csv"
    await _save_temp_file(file, tmp_path, "network")

    try:
        result = ingest_network_csv(db=db, run_id=run_id or "", csv_path=tmp_path)
        rows = _extract_rows(result)
    except Exception as e:  # noqa: BLE001
        raise HTTPException(status_code=500, detail=f"Failed to ingest network CSV: {e}")

    if run_id:
        try:
            increment_ingest_counts(run_id, network=rows)
        except Exception:
            pass

    return {
        "kind": "network",
        "rows_ingested": rows,
        "run_id": run_id,
        "message": f"Ingested {rows} network rows.",
    }


@router.post("/databases")
async def ingest_databases(
    file: UploadFile = File(..., description="Databases CSV"),
    run_id: Optional[str] = Form(None),
    db: Session = Depends(get_db),
):
    """
    Ingest a databases CSV. For now we do NOT increment any run counters.
    """
    tmp_path = "/tmp/ingest_databases.csv"
    await _save_temp_file(file, tmp_path, "databases")

    try:
        result = ingest_databases_csv(db=db, run_id=run_id or "", csv_path=tmp_path)
        rows = _extract_rows(result)
    except Exception as e:  # noqa: BLE001
        raise HTTPException(status_code=500, detail=f"Failed to ingest databases CSV: {e}")

    return {
        "kind": "databases",
        "rows_ingested": rows,
        "run_id": run_id,
        "message": f"Ingested {rows} database rows.",
    }


@router.post("/business")
async def ingest_business(
    file: UploadFile = File(..., description="Business metadata CSV"),
    run_id: Optional[str] = Form(None),
    db: Session = Depends(get_db),
):
    """
    Ingest business metadata for applications.
    """
    tmp_path = "/tmp/ingest_business.csv"
    await _save_temp_file(file, tmp_path, "business")

    try:
        result = ingest_business_csv(db=db, run_id=run_id or "", csv_path=tmp_path)
        rows = _extract_rows(result)
    except Exception as e:  # noqa: BLE001
        raise HTTPException(status_code=500, detail=f"Failed to ingest business CSV: {e}")

    return {
        "kind": "business",
        "rows_ingested": rows,
        "run_id": run_id,
        "message": f"Ingested {rows} business metadata rows.",
    }


@router.post("/dependencies")
async def ingest_dependencies(
    file: UploadFile = File(..., description="Application dependencies CSV"),
    run_id: Optional[str] = Form(None),
    db: Session = Depends(get_db),
):
    """
    Ingest application-to-application dependencies.
    """
    tmp_path = "/tmp/ingest_dependencies.csv"
    await _save_temp_file(file, tmp_path, "dependencies")

    try:
        result = ingest_dependencies_csv(db=db, run_id=run_id or "", csv_path=tmp_path)
        rows = _extract_rows(result)
    except Exception as e:  # noqa: BLE001
        raise HTTPException(status_code=500, detail=f"Failed to ingest dependencies CSV: {e}")

    return {
        "kind": "dependencies",
        "rows_ingested": rows,
        "run_id": run_id,
        "message": f"Ingested {rows} dependency rows.",
    }


@router.post("/os")
async def ingest_os(
    file: UploadFile = File(..., description="OS & software metadata CSV"),
    run_id: Optional[str] = Form(None),
    db: Session = Depends(get_db),
):
    """
    Ingest OS & software metadata for servers.
    """
    tmp_path = "/tmp/ingest_os_metadata.csv"
    await _save_temp_file(file, tmp_path, "OS metadata")

    try:
        result = ingest_os_csv(db=db, run_id=run_id or "", csv_path=tmp_path)
        rows = _extract_rows(result)
    except Exception as e:  # noqa: BLE001
        raise HTTPException(status_code=500, detail=f"Failed to ingest OS CSV: {e}")

    return {
        "kind": "os_metadata",
        "rows_ingested": rows,
        "run_id": run_id,
        "message": f"Ingested {rows} OS metadata rows.",
    }


@router.post("/licensing")
async def ingest_licensing(
    file: UploadFile = File(..., description="Licensing metadata CSV"),
    run_id: Optional[str] = Form(None),
    db: Session = Depends(get_db),
):
    """
    Ingest licensing metadata.
    """
    tmp_path = "/tmp/ingest_licensing.csv"
    await _save_temp_file(file, tmp_path, "licensing")

    try:
        result = ingest_licensing_csv(db=db, run_id=run_id or "", csv_path=tmp_path)
        rows = _extract_rows(result)
    except Exception as e:  # noqa: BLE001
        raise HTTPException(status_code=500, detail=f"Failed to ingest licensing CSV: {e}")

    return {
        "kind": "licensing",
        "rows_ingested": rows,
        "run_id": run_id,
        "message": f"Ingested {rows} licensing rows.",
    }


@router.post("/utilization")
async def ingest_utilization(
    file: UploadFile = File(..., description="Utilization metrics CSV"),
    run_id: Optional[str] = Form(None),
    db: Session = Depends(get_db),
):
    """
    Ingest utilization metrics for servers.
    """
    tmp_path = "/tmp/ingest_utilization.csv"
    await _save_temp_file(file, tmp_path, "utilization")

    try:
        result = ingest_utilization_csv(db=db, run_id=run_id or "", csv_path=tmp_path)
        rows = _extract_rows(result)
    except Exception as e:  # noqa: BLE001
        raise HTTPException(status_code=500, detail=f"Failed to ingest utilization CSV: {e}")

    return {
        "kind": "utilization",
        "rows_ingested": rows,
        "run_id": run_id,
        "message": f"Ingested {rows} utilization rows.",
    }


@router.post("/applications")
async def ingest_applications(
    file: UploadFile = File(..., description="Applications CSV"),
    run_id: Optional[str] = Form(None),
    db: Session = Depends(get_db),
):
    """
    Ingest an applications CSV. For now we do NOT increment any run counters.
    """
    tmp_path = "/tmp/ingest_applications.csv"
    await _save_temp_file(file, tmp_path, "applications")

    try:
        result = ingest_applications_csv(db=db, run_id=run_id or "", csv_path=tmp_path)
        rows = _extract_rows(result)
    except Exception as e:  # noqa: BLE001
        raise HTTPException(status_code=500, detail=f"Failed to ingest applications CSV: {e}")

    return {
        "kind": "applications",
        "rows_ingested": rows,
        "run_id": run_id,
        "message": f"Ingested {rows} application rows.",
    }
